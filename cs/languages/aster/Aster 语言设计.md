# Aster 语言设计

**Aster** 语言是笔者构想的一种通用的，静态弱类型的范型编程语言，其主要受启发于 **C++** 和 **Haskell** 编程语言。前者为 **Aster** 提供了语言风格的蓝本，后者则提供了类族和惰性求值等语言特性等作为参考。

[TOC]

## 对象和类型

**Aster** 语言中，每个对象都 *没有* 唯一确定的 **类型（Type）**；即使如此，它们 *一定* 有一个确定的 **存储类型（Storage Type）**。很多语言中，这两个概念并没有明显的区分。**Aster** 中对它们进行如下的定义：

- **类型**：规定对象属性的一个标签。
- **存储类型**：规定对象内存中存储模型的一个标签。存储类型也是类型

我们可以将类型理解成编程语言中能够定义变量的标识符，包括别名；而存储类型则是内置类型，如整数、数组、元组等。下面是一个 **C++** 和 **Aster** 语言中类型的对比示例：

```cpp
// 存储类型
char, int*, int (&)[3], int (*)(void), struct { int i; double d; };
// 类型
int, std::string, std::vector<int>::iterator;
```

```cpp
// 存储类型
char, &int, &int[3], int -> (), (int, double)
// 类型
int, std::str, std::vec<int>::iter;
```

**Aster** 语言中的对象 *总是* 通过 **字面量（Literal）** 构建。字面量也 *唯一* 对应一个存储类型，它们是我们定义变量的重要途径，下面将逐一介绍。

### 字面量

**整数字面量（Integer Literal）** 对应着 **Aster** 中的 `int` 类型，这是一个 64 位的无限精度有符号整数存储类型。所有由 $0-9$ 组成的序列都是 *十进制* 整数，比如 `123`、`0003` 等。为了对其它进制提供支持，以 `_<base>` 结尾的数字和字母序列同样会被当作是 `base` 进制整数（`base` 是一个十进制整数），只要其中不出现非法的数字，比如八进制中不能出现 8 以上的数，十六进制中不能出现 f/F 以后的字母等。对于十以上进制的数字，由于数字开头可能出现字母导致和变量混淆，可以通过添加额外的 0 解决。下面是一些示例：

```cpp
// 十进制整数字面量
123, 00123;
// 八进制整数字面量
1357_8, 01_8;
// 十六进制整数字面量
0fff_16, 0a120_16
```

**小数字面量（Decimal Literal）** 对应着 **Aster** 中的 `dec` 类型，这是一个 128 位的无限精度小数存储类型。所有由小数点 `.` 和数字 $0-9$，包括指数 e/E 组成的序列都是小数，比如 `.123`、`1e10` 等。注意，指数符号 e/E 之后出现的必须是合法的十进制整数字面量（可以带有一个负号前缀），下面是一些示例：

```cpp
// 小数字面量
1.234, .01234, 1e10, 1.234e5, 2.0e-5
```

**分数字面量（Fractional Literal）** 对应着 **Aster** 中的 `frac` 类型，这是一个 128 位的无限精度分数存储类型。所有由分数符号 `</>` 和数字 $0-9$ 组成的序列都是分数，比如 `123</>1`、`233</>122` 等。下面是一些示例：

```cpp
// 分数字面量
1</>1, 1000</>0, 123</>246
```

**字符字面量（Character Literal）** 对应着 **Aster** 中的 `char` 类型，这是一个 16 位的无符号字符存储类型。所有由单引号对 `''` 包含的至多两个字符的序列都是字符，比如 `'a'`、`'\x11\x22'` 等。

**字符串字面量（String Literal）** 对应着 **Aster** 中的 `[char]` 类型。这是一个不确定大小的字符数组存储类型。所有由双引号对 `""` 包含的字符序列都是字符串，比如 `"Hello, World!"`、`"\v\a\n\t"` 等。

**数组字面量（Array Literal）** 对应着 **Aster** 中的 `[T]` 类型。这是一个不确定大小的 *特定类型* 数组存储类型。所有由方括号对 `[]` 包含的同类型元素序列都是数组。比如 `[1, 2, 3]`、`["abc", "def"]` 等。下面是它和 **C++** 中数组的对比：

```cpp
int arr[] = { 1, 2, 3 };
std::cout << arr[0];
```

```cpp
auto arr = [1, 2, 3];
print arr[0];
```

**列表字面量（List Literal）** 对应着 **Aster** 中的 `T:[] | []` 类型。这是一个不确定大小的 *特定类型* 链表存储类型。所有由冒号 `:` 连接的同类型元素序列（最后一个必须是空列表 `[]`）都是列表。比如 `1:2:3:[]`、`"abc":"def":[]` 等。下面是它和 **C++** 中列表的对比：

```cpp
std::list<int> l = { 1, 2, 3 };
l.push_front(0);
```

```cpp
auto l = 1 : 2 : 3 : [];
l @= 0 : l;
```

**结构体字面量（Structure Literal）** 对应着 **Aster** 中的元组类型。这是一个不确定大小的元组存储类型。所有由括号对 `()` 包含的，由零或多个逗号间隔的键值对或值都是元组，比如 `(1, "abc")`、`(name = "Yiming", age = 22)` 等。元组是非常重要的字面量，我们可以用它创建复杂的存储类型。相比 **C++** 的元组，它要简洁得多：

```cpp
std::tuple<int, std::string> tup = { 10, "abc" };
std::cout << "Number: " << get<0>(tup) << "; String: " << get<1>(tup);
```

```cpp
auto tup = (Number = 10, String = "abc");
print tup
```

空元组 `()` 是一个比较特别的字面量，因为它自己的类型也是 `()`。我们时常用它表示不存在的值。

**闭包字面量（Closure Literal）** 对应着 **Aster** 中的函数类型。这是一个至少为 64 位的函数存储类型。所有由类似于 `[]() -> {}` 的结构都是函数/闭包。比如 `() -> 10`、`[glob](auto x){ auto y = glob + x; return x * y; }` 等。**Aster** 对闭包语法的简化程度要胜于 **C++**。闭包的任一个成分都能省略。

```cpp
auto global = 10;
auto lambda_1 = [] { return 10; };
auto lambda_2 = [] (auto x) { return x * 2; };
auto lambda_3 = [global] (auto x) { return global + x; };
```

```cpp
auto global = 10;
auto lambda_1 = () -> 10;
auto lambda_2 = (auto x) -> x * 2;
auto lambda_3 = [global] (auto x) -> global + x;
```



### 变量

和大多数语言一样，我们可以轻松地定义 **Aster** 变量：

```cpp
auto i = 10;		// 定义一个值变量，i 和右侧的对象进行绑定
auto s = &"abc";	// 定义一个引用变量，i 和右侧的对象地址进行绑定，但进行任何操作时都会首先解引用，直接对对象进行操作
```

这里的 `auto` 关键字和 **C++** 中的作用基本一致。它可以对初始化部分进行 `auto` 类型推导（规则和 **C++** 略有不同）。上式等价于下面的 **C++** 语句：

```cpp
int i = 10;
char (const &s)[4] = "abc";
```

只不过在 **Aster** 中，我们显式指定的类型格式略有不同：

```cpp
int i = 10;
const s :: &char[] = "abc";
```

在 **Aster** 中，所有引用都默认被 `const` 修饰符修饰，这意味着我们不能通过引用来修改其指向的对象。如果需要进行非常数引用，需要使用 `mutable` 关键字：

```cpp
mutable s = &"abc";
s[0] = 'b';
```

我们也可以让值变量被修饰为 `const` 的，只需要使用这个关键字：

```cpp
const i = 10;
```

无论是 `mutable` 还是 `const` 都和 `auto` 使用同样的类型推导规则，只是在最外层加上了 `mutable` 或 `const` 修饰符。**Aster** 没有 **C++** 中的 `decltype(auto)` 类型推导机制，但是提供了其它的机制，我们在后面会介绍到。

需要注意，默认情况下，`auto` 仅对存储类型进行推导，如果需要推导为特定的类型，需要使用 `as` 关键字进行 **类型推导指引（Type Deduction Guide）**：

```cpp
type Int = int;
type MyTuple = (int, double);
const i = 10 as Int;
const t = (10, 1.0) as MyTuple;
```

类型推导指引要求给出的值和类型拥有完全一致的存储类型。

#### 声明与初始化

变量的 **声明（Declaration）** 是所有将一个新的 **标识符（Identifier）** 引入程序的语句：

```cpp
auto i :: int;
const str :: &char[] = &"abc";
```

如果一个声明中没有为变量赋值，即 **初始化（Initialization）**，此时变量的值是未知的，编译器会检查其是否在 *需要它的值* 前进行赋值，如果没有则会报错。初始化仅有一种语法，即 `= <init-expression>`，不需要像 **C++** 那样复杂到令人感觉迷惑。所有带有初始化结构的声明语句都被称为 **定义（Definition）**。







