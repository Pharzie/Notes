# C 学习

[TOC]

## **C** 语言的历史和简介

**C** 语言是一个古老却依然耀眼的语言，直至今日依然在系统编程领域占据统治地位。

它诞生于 20 世纪 70 年代，早起的 **C** 为了方便编译器的实现引入了不少（或许）具有争议的特性，比如数组下标从 0 开始（最早可能追溯到 **BCPL**）、数组与指针的近乎等同、`register` 关键字等。其中也有一些影响到后来出现的语言，尤其是 **C++**。可以说，从一开始，**C** 语言就在避免一些复杂的语言特性，让其编译器便于编写的同时也让 **C** 非常贴近于汇编语言。

70 年代中期，**C** 语言经典作品 *The C Programming Language* 出版并广受欢迎。我们将这本书里描述的 **C** 语言标准以其两位作者的首字母命名，即 **K&R C**。其中包含了大部分我们熟悉的 **C** 语言特性，不过与后来的 **C** 语言标准仍有区别，我们马上会介绍。

80 年代，**C** 被广泛运用，但因为缺少标准，不同的编译器实现的特性都有所差异。为了确保 **C** 不变为一个松散的语族，**ANSI** 为 **C** 制定了一个标准，并在后来被 **ISO** 采纳。这就是我们熟知的 **ANSI C**。在这个标准中，引入了一系列有趣的术语，我们可能会在不少其它语言的标准中看到这样的描述：

- **不可移植的代码（Unportable Code）**：其中可能包括 **由实现定义的（Implementation-Defined）**，即编译器设计者所决定的，在不同编译器中的不同行为，但它们都是正确的行为；**未申明的（Unspecified）**，即标准中没有规定正确的行为，比如参数的求值顺序。
- **坏代码（Bad Code）**：即 **未定义的（Undefined）**，因为没有按照正确方式编写，程序可能采取任何可能的行动。通常，在标准中可能会给出一系列 **约束条件（Constraint）**，在没有遵守其中的要求时，程序的行为就是未定义的，比如 `%` 运算符需要操作数均为整型。在违反约束条件或语法规则时，编译器会产生警告信息；但是不受约束的未定义行为并不一定会受到检查。**C++** 中的 **未定义行为（Undefined Bahavior, UB）** 是同样的概念。
- **可移植的代码（Portable Code）**：一个 **严格遵循标准（Strictly-Conforming）** 的程序不依赖于任何未申明的或未定义的特性，它可以在任何平台的任何编译器中都会有相同的输出。相比之下，一个 **遵循标准（Conforming）** 的程序只忠于特定的编译器，因为它可能依赖于该编译器中的由实现定义的或未申明的行为。

后文中，我们只会给出遵循标准的代码。

### **K&R C** 和 **ANSI C** 的对比

## **C** 程序的结构

一个 **C** 程序通常是

### **C** 文件

一个 **C** 文件通常包括一系列 **预处理指令（Preprocessor Directive）**、**函数（Function）** 及 **变量（Variable）** 的定义、**结构体（Structure）** 及 **枚举（Enumeration）** 的定义，以及 **类型别名（Type Alias）** 的声明。接下来让我们快速地浏览这些概念，然后在后文中详细地介绍。

预处理指令是一些以 `#` 符号开头的标签，比如 `#define` 就是预处理定义指令，这里 `#` 和 `define` 之间可以有任意的空格。比较常用的预处理指令有下面这些：

```c
// define 指令所做的就是文本替换；
#define VARLIKE_MACRO 10

```



