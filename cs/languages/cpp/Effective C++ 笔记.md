# Effective C++ 笔记

[TOC]

本篇是 *Effective C++ (Scott Meyers)* 的阅读笔记，会遵照原文进行分章。

## 让自己熟悉 **C++**

### 将 **C++** 视为一个语言联邦

### 优先使用 `const`、`enum`、`inline` 而非 `#define`

### 尽可能使用 `const`

### 确定对象在使用前已经被初始化

## 构造函数/析构函数/赋值运算符

### 了解 **C++** 默默编写并调用哪些函数

### 如果不想使用编译器自动生成的函数，应该明确禁止它

### 为多态基类声明 `virtual` 析构函数

### 不要让析构函数抛出异常

### 不要在构造和析构函数中使用 `virtual` 函数

### 让 `operator =` 函数返回一个对 `*this` 的引用

### 在 `operator =` 中处理自我赋值

### 复制对象中的每一个成分

## 资源管理

### 以对象管理资源

### 在资源管理类中小心复制行为

### 在资源管理类中提供对原始资源的访问

### 成对使用 `new` 和 `delete` 时使用相同的形式

### 以独立语句将 `new` 得到的对象存入智能指针中

## 设计与声明

### 让接口容易被正确使用

### 将类设计得像一个类型

### 优先以常引用传递而非以值传递

### 不要返回引用类型

### 将成员变量声明为 `private`

### 优先使用非成员函数和非友元函数而非成员函数

### 如果所有参数都需要类型转换，请使用非成员函数

### 考虑写一个不抛出异常的 `swap` 函数

## 实现

### 尽可能延后变量定义出现的地方

### 尽可能减少类型转换

### 避免返回对象内部的“句柄”

### 为异常安全而努力

### 彻底了解内联

### 将文件间的编译依赖关系降到最低

## 继承与面向对象设计

### 确保 `public` 继承体现了 is-a 的关系

### 避免名称覆盖

### 区分对接口和对实现的继承

### 考虑 `virtual` 函数以外的其它选择

### 绝不重新定义继承的非 `virtual` 函数

### 绝不重新定义继承的默认参数值

### 通过组合体现 has-a 关系

### 审慎地使用 `private` 继承

### 审慎地使用多重继承

## 模版和范型编程

### 了解隐式接口和编译器多态

### 了解 `typename` 的双重含义

### 了解如何访问模版化的基类中的名称

### 将与模版参数无关的代码抽出模版

### 通过模版成员函数接受所有兼容类型

### 需要类型转换时在模版中定义非成员函数

### 使用特征类型表现类型信息

### 认识模版元编程

## 自定义 `new` 和 `delete`

### 了解 new-handler 的行为

### 了解替换 `new` 和 `delete` 的合理时机

### 编写 `new` 和 `delete` 时遵守约定

### 如果写了 placement-new，也要写 place-delete

## 杂项

### 注意编译器的警告

### 熟悉包括 **TR1** 在内的标注库

### 熟悉 **Boost**

