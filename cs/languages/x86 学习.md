# x86 学习

[TOC]

本篇笔记中我们将使用 **AT&T(GAS)** 的 **x86** 语法。

## 基础知识

每个 **x86** 语句都由指令和操作数构成，比如 `mov $0x15, %eax` 就是一个语句。其中由空格分开的第一部分是 **指令（Opcode）**，而后面的部分都是 **操作数（Operand）**。可以将操作数分为下面几种：

- **立即数（Immediate）**：也即常数，由 `$` 开始的一个数字序列
- **寄存器（Register）**：代表了处理器中的特殊存储单元，由 `%` 开始的一个字符序列
- **内存地址（Memory Address）**：代表了内存中的某个地址，由 `()` 结构提示，我们会在后文提到

### 寄存器

寄存器的名称并不是随意的字符序列，而是固定名称的一些。部分寄存器有特殊含义，列出如下：

- EAX：表示返回值
- ECX：循环的计数器
- EDI：重复的终点
- ESI：重复的起点
- EBP：基指针
- ESP：栈指针
- EIP：程序计数器
- EFLAGS：上一个操作的状态

### 内存操作

**x86** 使用一个特殊的语法来访问内存空间，比如将 `Mem[EBP + 8 + 4 * ECX]` 加载入 `EAX` 可以写作 `mov 8(%ebp, %ecx, 4), %eax`，注意到这里出现的数字不需要 `$`，因为它们并不是立即数。其语法解释如下：

`displacement(base_reg, offset_reg, multiplier)` => `base_reg + displacement + offset_reg * multiplier`

其中并不是所有项都是必须的。作为举例，下面是一段 **C** 代码：

```c
typedef struct {
    int a, b, c, d;
} foo_t;
foo_t my_foos[10];
my_foos[5].c = 461;
```

我们可以尝试写出与其等价的 **x86** 指令（我们这里假设 `EBX` 存储了指向 `my_foos` 的指针：

```assembly
mov $5, %ecx
movl $461, 8(%ebx, %ecx, 16)	# 这里的 8 是因为 c 处于第三个；16 是因为取的是 my_foos[5]（默认 sizeof(int) 是 4）
```

### 常见指令

算术指令诸如 `add`、`sub`、`inc`、`dec`、`neg` 都很好理解。也有位运算指令比如 `and`、`or`、`xor`、`not` 等，和 `shl` 与 `shr`（左移位和右移位）。下面我们重点介绍一下转移指令：

- `mov` 指令将第一个操作数的数据复制给第二个操作数
- `lea` 指令计算出某个地址并复制给第二个操作数
- `push` 指令将操作数压入栈顶
- `pop` 指令将栈顶的数推出并复制给操作数
- `jmp` 指令跳转到操作数所提示的标签或地址
-  `je/jne/jg/jge/jl/jle` 是条件跳转指令，其检查 `EFLAGS` 寄存器中的数是否等于/不等于/等于 0/大于/大于等于/小于/小于等于操作数，如果确实如此则进行跳转
- `jz` 检查 `EFLAGS` 寄存器是否等于 0，如果是则进行跳转
