# 计算机安全

[TOC]

## 控制流劫持

**控制流劫持（Control Overflow Hijacking）** 是让程序的控制流发生改变并执行攻击者的指令。

### 缓冲区溢出

**缓冲区溢出（Buffer Overflow）** 是当我们对超出数组大小的部分进行读写时出现的错误。可以通过下面的例子进行理解：

```c
void foo() {
 	char buf[16];
    gets(buf);			// gets 是一个危险的函数，它不对缓冲区边界进行任何检查，输入多少就向缓冲区写入多少
}
```

`buf` 在 `foo` 调用是在栈上得到了 16 个字节的空间，然而输入，比如 `"good morning you are hacked"` 的长度超过了这段空间。多出的字符会覆盖栈上存储的参数，甚至函数的返回地址。这就可能导致函数返回到任意指定的地址处，执行攻击者提前放置的恶意代码。这个恶意代码通常就是输入的字符串的某个位置。

我们可以直接尝试调用 shell 来侵入系统。利用恶意函数打开 shell 之后，就可以方便地直接使用指令了：

```assembly
# 一个 shellcode 程序
push	$0xb			# execve 的地址
pop		%eax			# EAX = 0xb
xor		%ecx, %ecx		# ECX = 0x0
xor		%edx, %edx		# EDX = 0x0
push	%edx			# 0
push	$0x68732f2f		# "//sh"，注意 Intel 是小端（Little Endian）的，因此字符串是从低字节读向高字节
push	$0x6e69622f		# "/bin"
mov		%esp, %ebx		# EBX = "/bin//sh"
int		$0x80			# 进行系统调用
```

可以发现中间有一些别扭的操作，比如对 EAX 赋值时首先 `push` 然后再 `pop`；对 ECX、EDX 赋 0 时使用 `xor` 等，这是因为为了利用 `gets` 等函数和伪装成字符串的恶意代码，需要注意所有 `'\0'` 会终止字符串，以及所有 `'\n'` 会终止 `gets`，所有 `' '` 会终止 `scanf`，我们需要避免这一点。

那么如何保证我们一定能够覆盖函数的返回地址，并且准确找到恶意代码的地址呢？通常的方案是：

- **nop sled**：在 shellcode 开始之前放置很多个 `nop` 指令，这样即使跳转地址不是真正的 shellcode，也会在执行一定的 `nop`（空指令）后开始执行 shellcode
- 在 shellcode 之后放置一系列对缓冲区地址的猜测（这也是基于 shellcode 中调用 `execve` 后的代码不会执行），这样有更高概率越过缓冲区长度并覆盖返回地址

### 栈金丝雀

**栈金丝雀（Stack Canary）** 是一个能够检验返回地址被覆盖的机制。它将某一个特殊值（即 **金丝雀（Canary）**）存入返回地址之前的栈上的某个地址，并在执行 `ret` 时对其进行检查。如果金丝雀被修改了，那么就认为返回地址被覆盖了。下面是一段演示代码：

```assembly
foo:
	push	%ebp
	mov		%esp, %ebp
	push	CANARY
	sub		$16, %esp
	# 省略定义部分
	call	gets
	mov		-4(%ebp), %eax
	cmp		CANARY, %eax
	jne		stack_chk_fail		# 这是一个特殊的地址
	leave
	ret
```

为了破解栈金丝雀，我们需要保证 shellcode 中包含金丝雀。不过由于前面提到的标准库函数有不同的终止符，当金丝雀的值是 0 时，我们就不能通过 `strcpy` 来执行恶意代码；当金丝雀的值是 `'\n'` 时，就不能通过 `gets` 来执行恶意代码；当金丝雀的值是根据一些条件随机生成的，就不能通过 `write` 来执行恶意代码。

总结来讲，栈金丝雀是一个非常轻量却有效的阻止缓存区溢出导致返回地址被覆盖的方法。在 **GCC** 和 **Clang** 中这是默认实施的机制，可以通过 `-fno-stack-protector` 来禁止这个机制。

### 安全函数

比较好的根除缓冲区溢出的方式是干脆不使用那些有问题的函数，如 `gets`、`strcpy` 等，而是使用指定了读写字节数的 `fgets`、`strncpy` 等。通过指定输入的最大字节数，可以阻止 shellcode 任意注入代码。

### 变种：函数指针

我们可以通过函数指针来进行控制流劫持：

```c
struct msg_t {
  	char text[128];
    void (*foo)(char*);
};
```

此时可以通过让 `text` 溢出来让 `foo` 指向攻击者给定的恶意函数。**C++** 也有类似的用法，其通过虚函数做到：

```cpp
class Shape {
public:
  	virtual float area();  
};
class Circle : public Shape {
public:
   	Circle(float r_) : r(r_) {}
    float area() const override { return PI * r * r; }
private:
    float r;
};
class Square : public Shape {
public:
    Square(float a_) : a(a_) {}
    float area() const override { return r * r; }
private:
    float a;
};
```

虚函数本质的实现方式是在对象的开头存储一个虚指针，指向其实例类型需要调用的成员函数表。我们可以在这样的虚对象前设立一个数组，然后通过缓冲区溢出来覆盖虚指针，让通过虚指针调用的函数为已经设置好的恶意代码（如 shellcode）。

### 变种：释放后使用

```c
struct msg_t {
  	void (*foo)(char*);
    char text[128];
};
struct student_t {
  	int uid;
    char name[128];
};

void hack() {
 	student_t* s = malloc(sizeof(student_t));
    free(s);
    msg_t* m = malloc(sizeof(msg_t));	// 这里分配的地址和 s 可能是一样的
    s->uid = update_uid();				// 这里会将 foo 覆盖，因为 uid 和 foo 占同样的内存空间
}
```

### 总结：缓冲区溢出

缓冲区溢出曾经是非常常见的攻击手段，但是随着栈金丝雀和更安全的函数的普及，它在内存安全中的威胁度下降了很多。不过它的变种，比如释放后使用，依然是主要的内存安全问题的诱因之一。

缓冲区溢出及其变种的本质实际上在于将数据和代码进行了混用。不难发觉数据的特点应该是可修改但不可执行，而代码的特点是可执行却不可修改。如果能够利用这个性质禁止执行数据的执行和可执行文件的修改，就能够杜绝该问题。不过即使如此，在已存在的代码中，我们依然能够找到漏洞。

### 返回到标准库攻击

